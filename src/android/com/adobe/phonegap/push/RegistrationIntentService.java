package com.adobe.phonegap.push;

import android.app.AlarmManager;
import android.app.PendingIntent;
import android.content.Context;

import android.app.IntentService;
import android.content.Intent;
import android.content.SharedPreferences;
import android.os.PowerManager;
import android.os.StrictMode;
import android.os.SystemClock;
import android.provider.Settings;
import android.util.Log;

import com.google.android.gcm.GCMRegistrar;
import com.google.android.gms.gcm.GoogleCloudMessaging;
import com.google.android.gms.iid.InstanceID;

import org.json.JSONException;
import org.json.JSONObject;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.Random;
import java.util.concurrent.TimeUnit;

import static com.google.android.gcm.GCMConstants.ERROR_SERVICE_NOT_AVAILABLE;
import static com.google.android.gcm.GCMConstants.EXTRA_ERROR;
import static com.google.android.gcm.GCMConstants.EXTRA_REGISTRATION_ID;
import static com.google.android.gcm.GCMConstants.EXTRA_SPECIAL_MESSAGE;
import static com.google.android.gcm.GCMConstants.EXTRA_TOTAL_DELETED;
import static com.google.android.gcm.GCMConstants.EXTRA_UNREGISTERED;
import static com.google.android.gcm.GCMConstants.INTENT_FROM_GCM_LIBRARY_RETRY;
import static com.google.android.gcm.GCMConstants.INTENT_FROM_GCM_MESSAGE;
import static com.google.android.gcm.GCMConstants.INTENT_FROM_GCM_REGISTRATION_CALLBACK;
import static com.google.android.gcm.GCMConstants.VALUE_DELETED_MESSAGES;

public class RegistrationIntentService extends IntentService implements PushConstants {
    public static final String LOG_TAG = "Push_RegistrationIntent";

    // instance counter
    private static final Random sRandom = new Random();
    private static final int MAX_BACKOFF_MS = (int) TimeUnit.SECONDS.toMillis(3600); // 1 hour

    // token used to check intent origin
    private static final String TOKEN = Long.toBinaryString(sRandom.nextLong());
    private static final String EXTRA_TOKEN = "token";

    // Java lock used to synchronize access to sWakelock
    private static final Object LOCK = RegistrationIntentService.class;

   // wakelock
    private static final String WAKELOCK_KEY = "GCM_LIB";
    private static PowerManager.WakeLock sWakeLock;

    public RegistrationIntentService() {
        super(LOG_TAG);
    }

    @Override
    protected void onHandleIntent(Intent intent) {
        try {
            Context context = getApplicationContext();
            String action = intent.getAction();
            if (action.equals(INTENT_FROM_GCM_REGISTRATION_CALLBACK)) {
                GCMRegistrar.setRetryBroadcastReceiver(context);
                handleRegistration(context, intent);
//            } else if (action.equals(INTENT_FROM_GCM_MESSAGE)) {
//                // checks for special messages
//                String messageType = intent.getStringExtra(EXTRA_SPECIAL_MESSAGE);
//                if (messageType != null) {
//                    if (messageType.equals(VALUE_DELETED_MESSAGES)) {
//                        String sTotal = intent.getStringExtra(EXTRA_TOTAL_DELETED);
//                        if (sTotal != null) {
//                            try {
//                                int total = Integer.parseInt(sTotal);
//                                Log.v(LOG_TAG, "Received deleted messages " + "notification: " + total);
//                                onDeletedMessages(context, total);
//                            } catch (NumberFormatException e) {
//                                Log.e(LOG_TAG, "GCM returned invalid number of " + "deleted messages: " + sTotal);
//                            }
//                        }
//                    } else {
//                        // application is not using the latest GCM library
//                        Log.e(LOG_TAG, "Received unknown special message: " + messageType);
//                    }
//                } else {
//                    onMessage(context, intent);
//                }
            } else if (action.equals(INTENT_FROM_GCM_LIBRARY_RETRY)) {
                String token = intent.getStringExtra(EXTRA_TOKEN);
                if (!TOKEN.equals(token)) {
                    // make sure intent was generated by this class, not by a
                    // malicious app.
                    Log.e(LOG_TAG, "Received invalid token: " + token);
                    return;
                }
                // retry last call
                if (GCMRegistrar.isRegistered(context)) {
                    GCMRegistrar.internalUnregister(context);
                } else {
                    String[] senderIds = GCMRegistrar.getSenderIds(context);
                    GCMRegistrar.internalRegister(context, senderIds);
                }
            }
        } finally {
            // Release the power lock, so phone can get back to sleep.
            // The lock is reference-counted by default, so multiple messages are ok.
            // If onMessage() needs to spawn a thread or do something else, it should use its own lock.
            synchronized (LOCK) {
                // sanity check for null as this is a public method
                if (sWakeLock != null) {
                    sWakeLock.release();
                } else {
                    // should never happen during normal workflow
                    Log.e(LOG_TAG, "Wakelock reference is null");
                }
            }
        }

        // default management
        SharedPreferences sharedPreferences = getApplicationContext().getSharedPreferences(COM_ADOBE_PHONEGAP_PUSH, Context.MODE_PRIVATE);

        try {
            InstanceID instanceID = InstanceID.getInstance(this);
            String senderID = sharedPreferences.getString(SENDER_ID, "");
            String token = instanceID.getToken(senderID,
                    GoogleCloudMessaging.INSTANCE_ID_SCOPE, null);
            PushPlugin.setRegistrationID(token);
            Log.i(LOG_TAG, "new GCM Registration Token: " + token);

        } catch (Exception e) {
            Log.d(LOG_TAG, "Failed to complete token refresh", e);
        }
    }

    private void handleRegistration(final Context context, Intent intent) {
        GCMRegistrar.cancelAppPendingIntent();
        String registrationId = intent.getStringExtra(EXTRA_REGISTRATION_ID);
        String error = intent.getStringExtra(EXTRA_ERROR);
        String unregistered = intent.getStringExtra(EXTRA_UNREGISTERED);
        Log.d(LOG_TAG, "handleRegistration: registrationId = " + registrationId + ", error = " + error + ", unregistered = "
                + unregistered);

        // registration succeeded
        if (registrationId != null) {
            GCMRegistrar.resetBackoff(context);
            GCMRegistrar.setRegistrationId(context, registrationId);
            onRegistered(context, registrationId);
            return;
        }

        // unregistration succeeded
        if (unregistered != null) {
            // Remember we are unregistered
            GCMRegistrar.resetBackoff(context);
            String oldRegistrationId = GCMRegistrar.clearRegistrationId(context);
            onUnregistered(context, oldRegistrationId);
            return;
        }

        // last operation (registration or unregistration) returned an error;
        Log.d(LOG_TAG, "Registration error: " + error);
        // Registration failed
        if (ERROR_SERVICE_NOT_AVAILABLE.equals(error)) {
            boolean retry = onRecoverableError(context, error);
            if (retry) {
                int backoffTimeMs = GCMRegistrar.getBackoff(context);
                int nextAttempt = backoffTimeMs / 2 + sRandom.nextInt(backoffTimeMs);
                Log.d(LOG_TAG, "Scheduling registration retry, backoff = " + nextAttempt + " (" + backoffTimeMs + ")");
                Intent retryIntent = new Intent(INTENT_FROM_GCM_LIBRARY_RETRY);
                retryIntent.putExtra(EXTRA_TOKEN, TOKEN);
                PendingIntent retryPendingIntent = PendingIntent.getBroadcast(context, 0, retryIntent, 0);
                AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
                am.set(AlarmManager.ELAPSED_REALTIME, SystemClock.elapsedRealtime() + nextAttempt, retryPendingIntent);
                // Next retry should wait longer.
                if (backoffTimeMs < MAX_BACKOFF_MS) {
                    GCMRegistrar.setBackoff(context, backoffTimeMs * 2);
                }
            } else {
                Log.d(LOG_TAG, "Not retrying failed operation");
            }
        } else {
            // Unrecoverable error, notify app
            onError(context, error);
        }
    }

    /**
     * Called from the broadcast receiver.
     * <p>
     * Will process the received intent, call handleMessage(), registered(), etc. in background threads, with a wake lock, while
     * keeping the service alive.
     */
    public static void runIntentInService(Context context, Intent intent, String className) {
        synchronized (LOCK) {
            if (sWakeLock == null) {
                // This is called from BroadcastReceiver, there is no init.
                PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
                sWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, WAKELOCK_KEY);
            }
        }
        sWakeLock.acquire();
        intent.setClassName(context, className);
        context.startService(intent);
    }

    /**
     * Called after a device has been registered.
     *
     * @param context
     *            application's context.
     * @param regId
     *            the registration id returned by the GCM service.
     */
    private void onRegistered(Context context, String regId) {
        Log.v(LOG_TAG, "onRegistered: " + regId);
        if (PushPlugin.isActive()) {
            try {
                JSONObject json = new JSONObject().put(REGISTRATION_ID, regId);
                Log.v(LOG_TAG, "onRegistered: " + json.toString());
                PushPlugin.sendEvent(json);
            } catch (JSONException e) {
                // No message to the user is sent, JSON failed
                Log.e(LOG_TAG, "onRegistered: JSON exception");
            }
        } else {
            try {
                String baseUrl = getBackendUrl(context);
                String packageId = getAccountManagerPackageId(context);
                Log.d(LOG_TAG, "Backend baseUrl=" + baseUrl);
                Log.d(LOG_TAG, "AccountManager packageId=" + packageId);
                if (baseUrl == null || packageId == null) {
                    Log.d(LOG_TAG, "Unable to perform backend login due to missing backend URL");
                    return;
                }

                /* retrieves current username and password */
                Log.d(LOG_TAG, "Retrieving login info");
                Context pkgContext = context.getApplicationContext().createPackageContext(packageId, 0);
                SharedPreferences settings = pkgContext.getSharedPreferences("LoginPrefs", 0);
                if (settings == null) {
                    Log.d(LOG_TAG, "Unable to perform backend login due to missing login preferences");
                    return;
                }
                String username = settings.getString("__USERNAME__", null);
                String password = settings.getString("__PASSWORD__", null);
                if (username == null || password == null) {
                    Log.d(LOG_TAG, "Unable to perform backend login due to missing username or password");
                    return;
                }
                String deviceId = Settings.Secure.getString(context.getContentResolver(), Settings.Secure.ANDROID_ID);
                RegistrationIntentService.BackendLoginRunnable runnable = new RegistrationIntentService.BackendLoginRunnable(username, password, baseUrl, regId, deviceId);
                new Thread(runnable).start();
            } catch (Exception e) {
                Log.e(LOG_TAG, "An error corred performing silent login", e);
            }
        }
    }

    private String getBackendUrl(Context context) {
        try {
            JSONObject descr = readFromfile("www/services/_backend.json", context);
            return descr.getString("baseUrl");
        } catch (Exception e) {
            Log.e(LOG_TAG, "Unable to retrieve the backend base URL", e);
        }
        return null;
    }

    private String getAccountManagerPackageId(Context context) {
        try {
            JSONObject descr = readFromfile("www/services/_security.json", context);
            return descr.getJSONObject("accountManager").getString("packageName");
        } catch (Exception e) {
            Log.e(LOG_TAG, "Unable to retrieve the account-manager package-id", e);
        }
        return null;
    }

    public static JSONObject readFromfile(String fileName, Context context) throws Exception {
        InputStream inputStream = null;
        InputStreamReader streamReader = null;
        BufferedReader reader = null;
        try {
            inputStream = context.getResources().getAssets().open(fileName);
            streamReader = new InputStreamReader(inputStream);
            reader = new BufferedReader(streamReader);
            String line = "";
            StringBuilder sb = new StringBuilder();
            while ((line = reader.readLine()) != null) {
                sb.append(line);
            }
            return new JSONObject(sb.toString());
        } catch (Exception e) {
            throw new Exception("Unable to read asset resource " + fileName, e);
        } finally {
            if (streamReader != null) {
                try {
                    streamReader.close();
                } catch (Throwable t) {
                }
            }
            if (inputStream != null) {
                try {
                    inputStream.close();
                } catch (Throwable t) {
                }
            }
            if (reader != null) {
                try {
                    reader.close();
                } catch (Throwable t) {
                }
            }
        }
    }

    private static class BackendLoginRunnable implements Runnable {

        private static final int MAX_RETRY = 10;

        private final String username;
        private final String password;
        private final String baseUrl;
        private final String registrationId;
        private final String deviceId;

        BackendLoginRunnable(String username, String password, String baseUrl, String registrationId, String deviceId) {
            super();
            this.username = username;
            this.password = password;
            this.baseUrl = baseUrl;
            this.registrationId = registrationId;
            this.deviceId = deviceId;
        }

        @Override
        public void run() {
            StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder().permitAll().build());
            // Retries many time with increasing time lapse in order to grant backend availability.
            // The backend could be accessible only through the WIFI which can takes several time to be available, respect on the GSM
            // network which is ready on startup and which allows the GCM registration but not the backend access.

            /* prepares the login request body */
            JSONObject requestJson = null;
            try {
                requestJson = new JSONObject();
                requestJson.put("username", username);
                requestJson.put("password", password);
                JSONObject device = new JSONObject();
                device.put("deviceId", deviceId);
                device.put("devicePlatform", "Android");
                device.put("notificationDeviceId", registrationId);
                requestJson.put("device", device);
            } catch (Throwable t) {
                Log.e(LOG_TAG, "Unable to prepare the login request", t);
                return;
            }

            /* performs the login (retrying it if necessary) */
            for (int i = 1; i <= MAX_RETRY; i++) {
                try {
                    Log.d(LOG_TAG, "Performing backend login for '" + username + "' (retry " + i + ")");
                    OutputStreamWriter requestWriter = null;
                    BufferedReader responseReader = null;
                    try {
                        URL url = new URL(baseUrl + "/users/login");
                        HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                        conn.setConnectTimeout(4000);
                        conn.setReadTimeout(4000);
                        conn.setDoOutput(true);
                        conn.setDoInput(true);
                        conn.setRequestProperty("Accept", "application/json");
                        conn.setRequestProperty("content-type", "application/json");
                        requestWriter = new OutputStreamWriter(conn.getOutputStream());
                        requestWriter.write(requestJson.toString());
                        requestWriter.flush();
                        final int code = conn.getResponseCode();
                        if (200 == code) {
                            return;
                        }

                        /* reads the response */
                        responseReader = new BufferedReader(new InputStreamReader(conn.getInputStream()));
                        StringBuilder response = new StringBuilder();
                        String line;
                        while ((line = responseReader.readLine()) != null) {
                            response.append("\n").append(line);
                        }
                        Log.e(LOG_TAG, "Unable to perform backend login (resultCode:" + code + ")" + response.toString());
                    } finally {
                        if (requestWriter != null) {
                            try {
                                requestWriter.close();
                            } catch (Throwable t) {
                                // ignores exceptions
                            }
                        }
                        if (responseReader != null) {
                            try {
                                responseReader.close();
                            } catch (Throwable t) {
                                // ignores exceptions
                            }
                        }
                    }
                } catch (Throwable t) {
                    // ignores exceptions
                }
                try {
                    Thread.sleep(i * 2000L);
                } catch (Throwable t2) {
                    // ignores exceptions
                }
            }
        }
    }

    /**
     * Called when a cloud message has been received.
     *
     * @param context
     *            application's context.
     * @param intent
     *            intent containing the message payload as extras.
     */
//    private void onMessage(Context context, Intent intent) {
//        Log.d(LOG_TAG, "onMessage - context: " + context);
//
//        // Extract the payload from the message
//        Bundle extras = intent.getExtras();
//        if (extras != null) {
//
//            SharedPreferences prefs = context.getSharedPreferences(PushPlugin.COM_ADOBE_PHONEGAP_PUSH, Context.MODE_PRIVATE);
//            boolean forceShow = prefs.getBoolean(FORCE_SHOW, false);
//
//            // if we are in the foreground and forceShow is `false` only send data
//            if (!forceShow && PushPlugin.isInForeground()) {
//                extras.putBoolean(FOREGROUND, true);
//                PushPlugin.sendExtras(extras);
//            }
//            // if we are in the foreground and forceShow is `true`, force show the notification if the data has at least a message or
//            // title
//            else if (forceShow && PushPlugin.isInForeground()) {
//                extras.putBoolean(FOREGROUND, true);
//
//                showNotificationIfPossible(context, extras);
//            }
//            // if we are not in the foreground always send notification if the data has at least a message or title
//            else {
//                extras.putBoolean(FOREGROUND, false);
//
//                showNotificationIfPossible(context, extras);
//            }
//        }
//    }

    /**
     * Called after a device has been unregistered.
     *
     * @param context
     *            application's context.
     * @param regId
     *            the registration id that was previously registered.
     */
    private void onUnregistered(Context context, String regId) {
        Log.d(LOG_TAG, "onUnregistered - regId: " + regId);
    }

    /**
     * Called when the GCM server tells pending messages have been deleted because the device was idle.
     *
     * @param context
     *            application's context.
     * @param total
     *            total number of collapsed messages
     */
//    private void onDeletedMessages(Context context, int total) {
//        Log.d(LOG_TAG, "onDeletedMessages - context: " + context + ", total: " + total);
//    }

    /**
     * Called on a registration error that could be retried.
     *
     * <p>
     * By default, it does nothing and returns {@literal true}, but could be overridden to change that behavior and/or display the
     * error.
     *
     * @param context
     *            application's context.
     * @param errorId
     *            error id returned by the GCM service.
     *
     * @return if {@literal true}, failed operation will be retried (using exponential backoff).
     */
    private boolean onRecoverableError(Context context, String errorId) {
        Log.d(LOG_TAG, "onRecoverableError - context: " + context + ", errorId: " + errorId);
        return true;
    }

    /**
     * Called on registration or unregistration error.
     *
     * @param context
     *            application's context.
     * @param errorId
     *            error id returned by the GCM service.
     */
    private void onError(Context context, String errorId){
        Log.d(LOG_TAG, "onError - context: " + context + ", errorId: " + errorId);
    }
}
